#!/usr/bin/env python3

import subprocess
import argparse
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Union

import yaml


@dataclass
class NodeStatus:
    name: str = None
    cpu_usage_cores: str = None
    cpu_usage_percent: float = None
    memory_usage_bytes: int = None
    memory_usage_percent: float = None
    age: str = None
    taints: List[Dict] = None
    k8s_version: str = None
    status: str = None
    version: str = None

    def taints_as_roles(self) -> str:
        return ",".join([taint["key"] for taint in self.taints])


class NodeList:
    def __init__(self, items: Union[Dict[str, NodeStatus], None] = None) -> None:
        self.items = items if items is not None else {}

    def append(self, item: NodeStatus) -> None:
        self.items[item.name] = item

    def update(self, name, item: NodeStatus) -> None:
        self.items[name] = item

    def __iter__(self):
        for node in self.items.values():
            yield node

    def __str__(self) -> str:
        out_lines_values = [
            [
                "NAME",
                "STATUS",
                "AGE",
                "VERSION",
                "CPU(cores)",
                "CPU%",
                "MEMORY(Mi)",
                "MEMORY%",
                "TAINTS",
            ]
        ]
        for node in self.__iter__():
            out_lines_values.append(
                [
                    node.name,
                    node.status,
                    node.age,
                    node.version,
                    str(node.cpu_usage_cores),
                    f"{node.cpu_usage_percent:.2f}%",
                    convert_bytes_to_mi(bytes_value=node.memory_usage_bytes),
                    f"{node.memory_usage_percent:.2f}%",
                    node.taints_as_roles(),
                ]
            )

        columns_width = [
            max(len(str(row[column_index])) for row in out_lines_values)
            for column_index in range(len(out_lines_values[0]))
        ]

        return "\n".join(
            "   ".join(
                f"{str(row[column_index]):<{columns_width[column_index]}}"
                for column_index in range(len(row))
            )
            for row in out_lines_values
        )


def convert_memory_to_bytes(memory_str: str) -> int:
    """Convert memory string from Mi/Gi to bytes."""
    if memory_str.endswith("Mi"):
        return int(float(memory_str.rstrip("Mi")) * 1024 * 1024)
    elif memory_str.endswith("Gi"):
        return int(float(memory_str.rstrip("Gi")) * 1024 * 1024 * 1024)
    elif memory_str.endswith("Ki"):
        return int(float(memory_str.rstrip("Ki")) * 1024)
    else:
        raise ValueError(f"Unknown memory unit in {memory_str}")


def convert_bytes_to_mi(bytes_value: int) -> str:
    """Convert bytes to Mi (Mebibytes) and return as a string with 'Mi' suffix."""
    mi_value = bytes_value / (1024 * 1024)
    return f"{mi_value:.2f}".rstrip("0").rstrip(".") + "Mi"


def format_age(age: timedelta) -> str:
    if age.days > 0:
        return f"{age.days}d"
    hours, remainder = divmod(age.seconds, 3600)
    if hours > 0:
        return f"{hours}h"
    minutes, seconds = divmod(remainder, 60)
    if minutes > 0:
        return f"{minutes}m"
    return f"{seconds}s"


def get_kubectl_output(command: List[str]) -> str:
    try:
        return subprocess.check_output(command).decode()
    except subprocess.CalledProcessError as e:
        print(f"Error executing command: {' '.join(command)}\n{e}")
        exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Kubernetes Cluster Node Analysis Script"
    )
    parser.add_argument(
        "--context", help="Specify the Kubernetes context to use", default=""
    )
    args = parser.parse_args()

    context_arg = ["--context", args.context] if args.context else []

    node_list = NodeList()

    top_nodes = get_kubectl_output(
        ["kubectl"] + context_arg + ["top", "nodes"]
    ).splitlines()[1:]

    get_nodes = yaml.safe_load(
        get_kubectl_output(["kubectl"] + context_arg + ["get", "nodes", "-oyaml"])
    )

    for top_node in top_nodes:
        (
            name,
            cpu_usage_cores,
            cpu_usage_percent,
            memory_usage_bytes,
            memory_usage_percent,
        ) = top_node.split()
        node_list.append(
            NodeStatus(
                name=name,
                cpu_usage_cores=cpu_usage_cores,
                cpu_usage_percent=float(cpu_usage_percent.rstrip("%")),
                memory_usage_bytes=convert_memory_to_bytes(memory_usage_bytes),
                memory_usage_percent=float(memory_usage_percent.rstrip("%")),
            )
        )

    for node in get_nodes["items"]:
        name = node["metadata"]["name"]
        creation_timestamp = node["metadata"]["creationTimestamp"]
        creation_time = datetime.strptime(creation_timestamp, "%Y-%m-%dT%H:%M:%SZ")
        now = datetime.now()
        age = now - creation_time

        status = (
            "Ready"
            if node["status"]["conditions"][-1]["status"] == "True"
            else "NotReady"
        )

        taints = node.get("spec", {}).get("taints", [])

        node_status = node_list.items[name]
        node_status.age = format_age(age)
        node_status.version = node["status"]["nodeInfo"]["kubeletVersion"]
        node_status.taints = taints
        node_status.status = status
        node_list.update(name, node_status)

    print(node_list)


if __name__ == "__main__":
    main()
